import { GenerateGroups } from "k6/x/grafana-alerting";
import http from "k6/http";
import { expect } from "https://jslib.k6.io/k6-testing/0.6.1/index.js";
import { envOrDefault, ensureConfig, buildRequestParams } from "./config.js";

const commonStages = [
  { target: 1, duration: "30s" }, // Start with 1 iteration per time unit for 30s
  { target: 3, duration: "30s" }, // Ramp up linearly (over 30s) to 3 iterations per time unit
  { target: 3, duration: "1m30s" }, // Maintain 3 iterations per time unit over the next minute and a half
  { target: 1, duration: "30s" }, // Ramp down to 1 iteration per time unit
];

const defaultPromDS = "grafanacloud-prom";
const defaultGroupLimit = 40;
const slowFilters = ["health", "rule_matcher", "state"];

export const options = {
  // This could take a while depending on the load.
  setupTimeout: "10m",
  teardownTimeout: "10m",
  thresholds: {
    "http_req_duration{page_loaded:1,slow_filters:false}": ["p(99)<3000"], // 99% of "non-slow" requests must complete below 3s.
    "http_req_duration{page_loaded:1,slow_filters:true}": ["p(99)<7000"], // 99% of "slow" requests must complete below 7s.
    "http_req_failed{page_loaded:1}": ["rate<0.01"], // Less than 1% failed requests.
  },

  scenarios: {
    no_filters: {
      exec: "noFilters",
      executor: "ramping-arrival-rate",
      startRate: 1,
      timeUnit: "1s",
      preAllocatedVUs: 10,
      maxVUs: 20, // If the preAllocatedVUs are not enough, we can initialize more
      stages: commonStages,
    },
    four_filters: {
      exec: "fourFilters",
      executor: "ramping-arrival-rate",
      startRate: 1,
      timeUnit: "1s",
      startTime: "3m", // Start after previous test
      preAllocatedVUs: 10,
      maxVUs: 20,
      stages: commonStages,
    },
    seven_filters: {
      exec: "sevenFilters",
      executor: "ramping-arrival-rate",
      startRate: 1,
      timeUnit: "1s",
      startTime: "6m", // Start after previous test
      preAllocatedVUs: 10,
      maxVUs: 20,
      stages: commonStages,
    },
    all_filters: {
      exec: "allFilters",
      executor: "ramping-arrival-rate",
      startRate: 1,
      timeUnit: "1s",
      startTime: "9m", // Start after previous test
      preAllocatedVUs: 10,
      maxVUs: 20,
      stages: commonStages,
    },
  },
};

export function setup() {
  const { url, token, username, password } = ensureConfig();
  const commonRequestParams = buildRequestParams(username, password, token);
  const skipSetup = envOrDefault("SKIP_SETUP", false);
  if (skipSetup) {
    console.log("Skipping setup");
    return { commonRequestParams, url };
  }

  const numAlerting = parseInt(envOrDefault("ALERT_RULE_COUNT", 100));
  const numRecording = parseInt(envOrDefault("RECORDING_RULE_COUNT", 100));
  const rulesPerGroup = parseInt(envOrDefault("RULES_PER_GROUP", 10));
  const groupsPerFolder = parseInt(envOrDefault("GROUPS_PER_FOLDER", 5));

  let input = {
    nuke: true, // Delete all auto-gen folders before starting
    numAlerting,
    numRecording,
    rulesPerGroup,
    groupsPerFolder,
    grafanaURL: url,
    token,
    username,
    password,
    orgId: 1,
    concurrency: 100,
  };

  console.log("Creating test data in Grafana");
  GenerateGroups(input);

  return { commonRequestParams, url };
}

export function noFilters({ commonRequestParams, url }) {
  // Empty filters.
  search(url, {}, defaultGroupLimit, commonRequestParams);
}

export function fourFilters({ commonRequestParams, url }) {
  const filters = {
    datasource_uid: defaultPromDS,
    receiver_name: "empty",
    "search.folder": "Alerts Folder", // Will match all rules generated by alerting-gen
    "search.rule_name": "A", // Any rules containing an "A" in its name
  };

  search(url, filters, defaultGroupLimit, commonRequestParams);
}

export function sevenFilters({ commonRequestParams, url }) {
  const filters = {
    datasource_uid: defaultPromDS,
    plugins: "hide",
    receiver_name: "empty",
    rule_type: "alerting", // Filter out recording rules
    "search.folder": "Alerts Folder",
    "search.rule_group": "---", // Will match all rules generated by alerting-gen
    "search.rule_name": "A", // Any rules containing an "A" in its name
  };

  search(url, filters, defaultGroupLimit, commonRequestParams);
}

export function allFilters({ commonRequestParams, url }) {
  const filters = {
    datasource_uid: defaultPromDS,
    health: "ok",
    plugins: "hide",
    receiver_name: "empty",
    rule_matcher: `{"name":"env","value":".*","isRegex":true,"isEqual":true}`, // Will match labels env=~.*
    rule_type: "alerting", // Filter out recording rules
    "search.folder": "Alerts Folder",
    "search.rule_group": "---", // Will match all rules generated by alerting-gen
    "search.rule_name": "A", // Any rules containing an "A" in its name
    state: "normal",
  };

  search(url, filters, defaultGroupLimit, commonRequestParams);
}

// search sends a request to the /rules endpoint with the given filters and limit.
// It checks that at least one rule is returned and the limit is being applied.
function search(url, filters, groupLimit, commonRequestParams) {
  const prometheusResponse = http.get(buildRulesURL(url, filters, groupLimit), {
    tags: {
      page_loaded: "1",
      slow_filters: Object.keys(filters).some((el) => slowFilters.includes(el)), // True if any filter is a "slow" filter
    },
    ...commonRequestParams,
  });
  const prometheusData = JSON.parse(prometheusResponse.body);
  const groups = prometheusData.data.groups;

  expect(groups.length).toBeGreaterThan(0);
  expect(groups.length).toBeLessThanOrEqual(groupLimit);

  return groups;
}

// buildRulesURL validates the filters and uses them (and the group limit) to build the URL.
function buildRulesURL(baseURL, filters, groupLimit) {
  if (!filters || Object.keys(filters).length === 0) {
    return `${baseURL}/api/prometheus/grafana/api/v1/rules?group_limit=${groupLimit}`;
  }

  const possibleFilters = [
    "datasource_uid",
    "search.rule_name",
    "search.rule_group",
    "search.folder",
    "plugins",
    "receiver_name",
    "rule_matcher",
    "rule_type",
    "state",
    "health",
  ];

  let filterArr = [];
  for (const [key, value] of Object.entries(filters)) {
    if (!possibleFilters.includes(key)) {
      throw Error(`filter ${key} does not exist`);
    }
    filterArr.push(`${key}=${encodeURIComponent(value)}`);
  }

  return `${baseURL}/api/prometheus/grafana/api/v1/rules?group_limit=${groupLimit}&${filterArr.join("&")}`;
}

export function teardown() {
  if (envOrDefault("SKIP_TEARDOWN", false)) {
    console.log("Skipping teardown");
    return;
  }

  const { url, token, username, password } = ensureConfig();
  console.log("Tearing down test data in Grafana");
  GenerateGroups({
    nuke: true, // Delete all auto-gen data
    grafanaURL: url,
    token,
    username,
    password,
  });
}
